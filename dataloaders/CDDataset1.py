from base import BaseDataSet, BaseDataLoader
from utils import pallete
import numpy as np
import os
import torch
from PIL import Image
from torch.utils.data import Dataset
from torchvision import transforms


class ImageDataset(BaseDataSet):
    def __init__(self, addGenerativePic=False, **kwargs):
        """
        :param addGenerativePic: Whether to append images generated by generative model to the original file list.
        """
        self.num_classes = 2
        self.load_memory = False
        self.palette = pallete.get_voc_pallete(self.num_classes)
        self.addGenerativePic = addGenerativePic
        super(ImageDataset, self).__init__(**kwargs)

    def _set_files(self):
        # 1. Read regular list
        if self.split == "val":
            file_list = os.path.join(self.root, 'list', "val.txt")
        elif self.split == "test":
            file_list = os.path.join(self.root, 'list', "test.txt")
        elif self.split in ["train_supervised", "train_unsupervised"]:
            file_list = os.path.join(self.root, 'list', f"{self.percnt_lbl}_{self.split}.txt")
        else:
            raise ValueError(f"Invalid split name {self.split}")

        with open(file_list, "r") as f:
            self.files = f.readlines()

        self.originDatasetLen = len(self.files)  # Record original data length first
        if self.split in ["train_supervised", "train_unsupervised"]:
            # 2. Whether to append generated image list
            if self.addGenerativePic:
                # Assume there is a file named "generativePic.txt" that stores the generated image list
                gen_file_list = os.path.join(self.root, 'list', 'generativePic.txt')
                if os.path.exists(gen_file_list):
                    with open(gen_file_list, "r") as f_gen:
                        filesGenerative = f_gen.readlines()
                    # Append generated image list to self.files
                    self.files += filesGenerative
                else:
                    print(f"[Warning] {gen_file_list} file does not exist, unable to append generated image list.")

    def _load_data(self, index):
        """
        Determine whether it's original data or generated data based on index, and concatenate corresponding paths.
        """
        if index < self.originDatasetLen:
            image_name = self.files[index].strip()
            image_A_path = os.path.join(self.root, 'A', image_name)
            image_B_path = os.path.join(self.root, 'B', image_name)
            label_path = os.path.join(self.root, 'label', image_name)
        else:
            image_name = self.files[index].strip()
            image_A_path = os.path.join(self.root, 'generativeFile', 'A', image_name)
            image_B_path = os.path.join(self.root, 'generativeFile', 'B', image_name)
            label_path = os.path.join(self.root, 'generativeFile', 'label', image_name)

        # Read and convert to array
        image_A = np.asarray(Image.open(image_A_path), dtype=np.uint8)
        image_B = np.asarray(Image.open(image_B_path), dtype=np.uint8)
        label = np.asarray(Image.open(label_path), dtype=np.int32)

        # image_id is used to distinguish sample names (not necessarily required)
        image_id = os.path.splitext(os.path.basename(image_A_path))[0]

        return image_A, image_B, label, [image_A_path, image_B_path, label_path]


class CDDataset(BaseDataLoader):
    def __init__(self, kwargs):
        """
        DataLoader wrapper class, consistent with project framework.
        """
        self.MEAN = [0.485, 0.456, 0.406]
        self.STD = [0.229, 0.224, 0.225]
        self.batch_size = kwargs.pop('batch_size')
        kwargs['mean'] = self.MEAN
        kwargs['std'] = self.STD

        # Default to False, can be enabled externally via CDDataset({'addGenerativePic': True, ...})
        self.addGenerativePic = kwargs.pop('addGenerativePic', True)

        try:
            shuffle = kwargs.pop('shuffle')
        except:
            shuffle = False
        num_workers = kwargs.pop('num_workers')

        # Initialize custom dataset and pass in addGenerativePic
        self.dataset = ImageDataset(addGenerativePic=self.addGenerativePic, **kwargs)
        super(CDDataset, self).__init__(self.dataset, self.batch_size, shuffle, num_workers, val_split=None)
